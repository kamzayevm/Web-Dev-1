export interface PartNameInfo {
    readonly [name: string]: string | boolean | number;
}
export declare const partNameMap: (partNameInfo: PartNameInfo) => string;
export declare const asPercent: (part: number, whole: number) => number;
export declare const clamp: (number: number, min: number, max: number) => number;
/**
 *
 * Returns an element's offset relative to its parent. Similar to element.offsetTop and element.offsetLeft, except the
 * parent doesn't have to be positioned relative or absolute.
 *
 * Work around for the following issues in Chromium based browsers:
 *
 * https://bugs.chromium.org/p/chromium/issues/detail?id=1330819
 * https://bugs.chromium.org/p/chromium/issues/detail?id=1334556
 *
 */
export declare function getOffset(element: HTMLElement, parent: HTMLElement): {
    top: number;
    left: number;
    right: number;
    bottom: number;
};
export declare function createCounter(): () => number;
export declare function isLTR(element: HTMLElement): boolean;
export declare function extractText<T extends Node>(arr: T[]): string[];
/**
 * Builds a string from format specifiers and replacement parameters.
 *
 * @example
 * ```typescript
 * format('{0} says "{1}".', 'John', 'Hello'); // 'John says "Hello".'
 * ```
 */
export declare function format(template: string, ...params: string[]): string;
/**
 * Parse the passed `value` as a number or return the `fallback` if it can't be done.
 *
 * @example
 * ```typescript
 * asNumber('5'); // 5
 * asNumber('3.14'); // 3.14
 * asNumber('five'); // 0
 * asNUmber('five', 5); // 5
 * ```
 */
export declare function asNumber(value: unknown, fallback?: number): number;
/**
 * Returns the value wrapped between the min and max bounds.
 *
 * If the value is greater than max, returns the min and vice-versa.
 * If the value is between the bounds, it is returned unchanged.
 *
 * @example
 * ```typescript
 * wrap(1, 4, 2); // 2
 * wrap(1, 4, 5); // 1
 * wrap(1, 4, -1); // 4
 * ```
 */
export declare function wrap(min: number, max: number, value: number): number;
export declare function isDefined<T = unknown>(value: T): boolean;
export declare function iterNodes<T = Node>(root: Node, whatToShow?: keyof typeof NodeFilter, filter?: (node: T) => boolean): Generator<T>;
export declare function getElementByIdFromRoot(root: HTMLElement, id: string): HTMLElement | null;
export declare function groupBy<T>(array: T[], key: keyof T | ((item: T) => any)): Record<string, T[]>;
