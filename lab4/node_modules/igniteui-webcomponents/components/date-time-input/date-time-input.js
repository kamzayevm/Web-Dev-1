var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import { DatePart, DateParts, DateTimeUtil, } from './date-util.js';
import { addKeybindings, arrowDown, arrowLeft, arrowRight, arrowUp, ctrlKey, } from '../common/controllers/key-bindings.js';
import { blazorTwoWayBind } from '../common/decorators/blazorTwoWayBind.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import messages from '../common/localization/validation-en.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { format, partNameMap } from '../common/util.js';
import { IgcMaskInputBaseComponent, } from '../mask-input/mask-input-base.js';
const converter = {
    fromAttribute: (value) => !value ? null : DateTimeUtil.parseIsoDate(value),
    toAttribute: (value) => value.toISOString(),
};
class IgcDateTimeInputComponent extends EventEmitterMixin(IgcMaskInputBaseComponent) {
    static register() {
        registerComponent(this);
    }
    get inputFormat() {
        return this._inputFormat || this._defaultMask;
    }
    set inputFormat(val) {
        if (val) {
            this.setMask(val);
            this._inputFormat = val;
        }
    }
    get value() {
        return this._value;
    }
    set value(val) {
        this._value = val
            ? DateTimeUtil.isValidDate(val)
                ? val
                : DateTimeUtil.parseIsoDate(val)
            : null;
        this.updateMask();
        this.updateFormValue();
        this.updateValidity();
        this.setInvalidState();
    }
    updateFormValue() {
        this._value
            ? this.setFormValue(this._value.toISOString())
            : this.setFormValue(null);
    }
    get minValue() {
        return this.min;
    }
    set minValue(value) {
        this.min = value;
    }
    get maxValue() {
        return this.max;
    }
    set maxValue(value) {
        this.max = value;
    }
    setDefaultMask() {
        if (!this._inputFormat) {
            this.updateDefaultMask();
            this.setMask(this._defaultMask);
        }
        if (this.value) {
            this.updateMask();
        }
    }
    setDisplayFormat() {
        if (this.displayFormat) {
            if (this.value) {
                this.maskedValue = DateTimeUtil.formatDate(this.value, this.locale, this.displayFormat, true);
            }
        }
    }
    promptChange() {
        if (!this.prompt) {
            this.prompt = this.parser.prompt;
        }
        else {
            this.parser.prompt = this.prompt;
        }
    }
    constraintChange() {
        this.updateValidity();
    }
    get hasDateParts() {
        const parts = this._inputDateParts ||
            DateTimeUtil.parseDateTimeFormat(this.inputFormat);
        return parts.some((p) => p.type === DateParts.Date ||
            p.type === DateParts.Month ||
            p.type === DateParts.Year);
    }
    get hasTimeParts() {
        const parts = this._inputDateParts ||
            DateTimeUtil.parseDateTimeFormat(this.inputFormat);
        return parts.some((p) => p.type === DateParts.Hours ||
            p.type === DateParts.Minutes ||
            p.type === DateParts.Seconds);
    }
    get targetDatePart() {
        let result;
        if (this.focused) {
            const partType = this._inputDateParts.find((p) => p.start <= this.inputSelection.start &&
                this.inputSelection.start <= p.end &&
                p.type !== DateParts.Literal)?.type;
            if (partType) {
                result = partType;
            }
        }
        else {
            if (this._inputDateParts.some((p) => p.type === DateParts.Date)) {
                result = DatePart.Date;
            }
            else if (this._inputDateParts.some((p) => p.type === DateParts.Hours)) {
                result = DatePart.Hours;
            }
            else {
                result = this._inputDateParts[0].type;
            }
        }
        return result;
    }
    get datePartDeltas() {
        return Object.assign({}, this._datePartDeltas, this.spinDelta);
    }
    constructor() {
        super();
        this.validators = [
            {
                key: 'valueMissing',
                message: messages.required,
                isValid: () => (this.required ? !!this.value : true),
            },
            {
                key: 'rangeUnderflow',
                message: () => format(messages.min, `${this.min}`),
                isValid: () => this.min
                    ? !DateTimeUtil.lessThanMinValue(this.value || new Date(), this.min, this.hasTimeParts, this.hasDateParts)
                    : true,
            },
            {
                key: 'rangeOverflow',
                message: () => format(messages.max, `${this.max}`),
                isValid: () => this.max
                    ? !DateTimeUtil.greaterThanMaxValue(this.value || new Date(), this.max, this.hasTimeParts, this.hasDateParts)
                    : true,
            },
        ];
        this._value = null;
        this._oldValue = null;
        this._datePartDeltas = {
            date: 1,
            month: 1,
            year: 1,
            hours: 1,
            minutes: 1,
            seconds: 1,
        };
        this.spinLoop = true;
        this.locale = 'en';
        addKeybindings(this, {
            skip: () => this.readOnly,
            bindingDefaults: { preventDefault: true },
        })
            .set([ctrlKey, ';'], () => (this.value = new Date()))
            .set(arrowUp, this.keyboardSpin.bind(this, 'up'))
            .set(arrowDown, this.keyboardSpin.bind(this, 'down'))
            .set([ctrlKey, arrowLeft], this.navigateParts.bind(this, 0))
            .set([ctrlKey, arrowRight], this.navigateParts.bind(this, 1));
    }
    connectedCallback() {
        super.connectedCallback();
        this.updateDefaultMask();
        this.setMask(this.inputFormat);
        this.updateValidity();
        if (this.value) {
            this.updateMask();
        }
    }
    stepUp(datePart, delta) {
        const targetPart = datePart || this.targetDatePart;
        if (!targetPart) {
            return;
        }
        const { start, end } = this.inputSelection;
        const newValue = this.trySpinValue(targetPart, delta);
        this.value = newValue;
        this.updateComplete.then(() => this.input.setSelectionRange(start, end));
    }
    stepDown(datePart, delta) {
        const targetPart = datePart || this.targetDatePart;
        if (!targetPart) {
            return;
        }
        const { start, end } = this.inputSelection;
        const newValue = this.trySpinValue(targetPart, delta, true);
        this.value = newValue;
        this.updateComplete.then(() => this.input.setSelectionRange(start, end));
    }
    clear() {
        this.maskedValue = '';
        this.value = null;
    }
    updateMask() {
        if (this.focused) {
            this.maskedValue = this.getMaskedValue();
        }
        else {
            if (!DateTimeUtil.isValidDate(this.value)) {
                this.maskedValue = '';
                return;
            }
            const format = this.displayFormat || this.inputFormat;
            if (this.displayFormat) {
                this.maskedValue = DateTimeUtil.formatDate(this.value, this.locale, format, true);
            }
            else if (this.inputFormat) {
                this.maskedValue = DateTimeUtil.formatDate(this.value, this.locale, format);
            }
            else {
                this.maskedValue = this.value.toLocaleString();
            }
        }
    }
    handleChange() {
        this.emitEvent('igcChange', { detail: this.value });
    }
    handleInput() {
        this.emitEvent('igcInput', { detail: this.value?.toString() });
    }
    handleDragLeave() {
        if (!this.focused) {
            this.updateMask();
        }
    }
    handleDragEnter() {
        if (!this.focused) {
            this.maskedValue = this.getMaskedValue();
        }
    }
    async updateInput(string, range) {
        const { value, end } = this.parser.replace(this.maskedValue, string, range.start, range.end);
        this.maskedValue = value;
        this.updateValue();
        this.requestUpdate();
        if (range.start !== this.inputFormat.length) {
            this.handleInput();
        }
        await this.updateComplete;
        this.input.setSelectionRange(end, end);
    }
    trySpinValue(datePart, delta, negative = false) {
        if (!delta) {
            delta = this.datePartDeltas[datePart] || 1;
        }
        const spinValue = negative ? -Math.abs(delta) : Math.abs(delta);
        return this.spinValue(datePart, spinValue);
    }
    spinValue(datePart, delta) {
        if (!this.value || !DateTimeUtil.isValidDate(this.value)) {
            return new Date();
        }
        const newDate = new Date(this.value.getTime());
        let formatPart, amPmFromMask;
        switch (datePart) {
            case DatePart.Date:
                DateTimeUtil.spinDate(delta, newDate, this.spinLoop);
                break;
            case DatePart.Month:
                DateTimeUtil.spinMonth(delta, newDate, this.spinLoop);
                break;
            case DatePart.Year:
                DateTimeUtil.spinYear(delta, newDate);
                break;
            case DatePart.Hours:
                DateTimeUtil.spinHours(delta, newDate, this.spinLoop);
                break;
            case DatePart.Minutes:
                DateTimeUtil.spinMinutes(delta, newDate, this.spinLoop);
                break;
            case DatePart.Seconds:
                DateTimeUtil.spinSeconds(delta, newDate, this.spinLoop);
                break;
            case DatePart.AmPm:
                formatPart = this._inputDateParts.find((dp) => dp.type === DateParts.AmPm);
                if (formatPart !== undefined) {
                    amPmFromMask = this.maskedValue.substring(formatPart.start, formatPart.end);
                    return DateTimeUtil.spinAmPm(newDate, this.value, amPmFromMask);
                }
                break;
        }
        return newDate;
    }
    async onWheel(event) {
        if (!this.focused || this.readOnly) {
            return;
        }
        event.preventDefault();
        event.stopPropagation();
        const { start, end } = this.inputSelection;
        event.deltaY > 0 ? this.stepDown() : this.stepUp();
        this.handleInput();
        await this.updateComplete;
        this.setSelectionRange(start, end);
    }
    updateDefaultMask() {
        this._defaultMask = DateTimeUtil.getDefaultMask(this.locale);
    }
    setMask(val) {
        const oldFormat = this._inputDateParts?.map((p) => p.format).join('');
        this._inputDateParts = DateTimeUtil.parseDateTimeFormat(val);
        val = this._inputDateParts.map((p) => p.format).join('');
        this._defaultMask = val;
        const newMask = (val || DateTimeUtil.DEFAULT_INPUT_FORMAT).replace(new RegExp(/(?=[^t])[\w]/, 'g'), '0');
        this._mask =
            newMask.indexOf('tt') !== -1
                ? newMask.replace(new RegExp('tt', 'g'), 'LL')
                : newMask;
        this.parser.mask = this._mask;
        this.parser.prompt = this.prompt;
        if (!this.placeholder || oldFormat === this.placeholder) {
            this.placeholder = val;
        }
    }
    parseDate(val) {
        if (!val) {
            return null;
        }
        return DateTimeUtil.parseValueFromMask(val, this._inputDateParts, this.prompt);
    }
    getMaskedValue() {
        let mask = this.emptyMask;
        if (DateTimeUtil.isValidDate(this.value)) {
            for (const part of this._inputDateParts) {
                if (part.type === DateParts.Literal) {
                    continue;
                }
                const targetValue = DateTimeUtil.getPartValue(part, part.format.length, this.value);
                mask = this.parser.replace(mask, targetValue, part.start, part.end).value;
            }
            return mask;
        }
        return this.maskedValue === '' ? mask : this.maskedValue;
    }
    isComplete() {
        return this.maskedValue.indexOf(this.prompt) === -1;
    }
    updateValue() {
        if (this.isComplete()) {
            const parsedDate = this.parseDate(this.maskedValue);
            if (DateTimeUtil.isValidDate(parsedDate)) {
                this.value = parsedDate;
            }
            else {
                this.value = null;
            }
        }
        else {
            this.value = null;
        }
    }
    getNewPosition(value, direction = 0) {
        const literals = this._inputDateParts.filter((p) => p.type === DateParts.Literal);
        let cursorPos = this.selection.start;
        if (!direction) {
            do {
                cursorPos = cursorPos > 0 ? --cursorPos : cursorPos;
            } while (!literals.some((l) => l.end === cursorPos) && cursorPos > 0);
            return cursorPos;
        }
        else {
            do {
                cursorPos++;
            } while (!literals.some((l) => l.start === cursorPos) &&
                cursorPos < value.length);
            return cursorPos;
        }
    }
    async handleFocus() {
        this.focused = true;
        this.updateMask();
        super.handleFocus();
        if (this.readOnly) {
            return;
        }
        this._oldValue = this.value;
        if (!this._value) {
            this.maskedValue = this.emptyMask;
            await this.updateComplete;
            this.select();
        }
    }
    handleBlur() {
        this.focused = false;
        if (!this.isComplete() && this.maskedValue !== this.emptyMask) {
            const parse = this.parseDate(this.maskedValue);
            if (parse) {
                this.value = parse;
            }
            else {
                this.value = null;
                this.maskedValue = '';
            }
        }
        else {
            this.updateMask();
        }
        if (this._oldValue !== this.value) {
            this.handleChange();
        }
        this.checkValidity();
        super.handleBlur();
    }
    navigateParts(delta) {
        const position = this.getNewPosition(this.input.value, delta);
        this.setSelectionRange(position, position);
    }
    async keyboardSpin(direction) {
        direction === 'up' ? this.stepUp() : this.stepDown();
        this.handleInput();
        await this.updateComplete;
        this.setSelectionRange(this.selection.start, this.selection.end);
    }
    renderInput() {
        return html `
      <input
        type="text"
        part=${partNameMap(this.resolvePartNames('input'))}
        name=${ifDefined(this.name)}
        .value=${live(this.maskedValue)}
        .placeholder=${live(this.placeholder || this.emptyMask)}
        ?readonly=${this.readOnly}
        ?disabled=${this.disabled}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @input=${super.handleInput}
        @wheel=${this.onWheel}
        @keydown=${super.handleKeydown}
        @click=${this.handleClick}
        @cut=${this.handleCut}
        @change=${this.handleChange}
        @compositionstart=${this.handleCompositionStart}
        @compositionend=${this.handleCompositionEnd}
        @dragenter=${this.handleDragEnter}
        @dragleave=${this.handleDragLeave}
        @dragstart=${this.handleDragStart}
      />
    `;
    }
}
IgcDateTimeInputComponent.tagName = 'igc-date-time-input';
export default IgcDateTimeInputComponent;
__decorate([
    property({ attribute: 'input-format' })
], IgcDateTimeInputComponent.prototype, "inputFormat", null);
__decorate([
    property({ converter: converter }),
    blazorTwoWayBind('igcChange', 'detail')
], IgcDateTimeInputComponent.prototype, "value", null);
__decorate([
    property({ converter: converter })
], IgcDateTimeInputComponent.prototype, "min", void 0);
__decorate([
    property({ converter: converter })
], IgcDateTimeInputComponent.prototype, "max", void 0);
__decorate([
    property({ attribute: 'min-value', converter: converter })
], IgcDateTimeInputComponent.prototype, "minValue", null);
__decorate([
    property({ attribute: 'max-value', converter: converter })
], IgcDateTimeInputComponent.prototype, "maxValue", null);
__decorate([
    property({ attribute: 'display-format' })
], IgcDateTimeInputComponent.prototype, "displayFormat", void 0);
__decorate([
    property({ attribute: false })
], IgcDateTimeInputComponent.prototype, "spinDelta", void 0);
__decorate([
    property({ type: Boolean, attribute: 'spin-loop' })
], IgcDateTimeInputComponent.prototype, "spinLoop", void 0);
__decorate([
    property()
], IgcDateTimeInputComponent.prototype, "locale", void 0);
__decorate([
    watch('locale', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "setDefaultMask", null);
__decorate([
    watch('displayFormat', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "setDisplayFormat", null);
__decorate([
    watch('prompt', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "promptChange", null);
__decorate([
    watch('min', { waitUntilFirstUpdate: true }),
    watch('max', { waitUntilFirstUpdate: true })
], IgcDateTimeInputComponent.prototype, "constraintChange", null);
//# sourceMappingURL=date-time-input.js.map